# Spec-Driven Development アプローチ

リバーシ（オセロ）の合法手判定プログラムを**仕様駆動開発（Specification-Driven Development）**で実装したアプローチです。

## 概要

このアプローチでは、以下の4フェーズで開発を進めました：

1. **Specify（仕様策定）**: `spec.md` の作成
2. **Plan（技術計画）**: `plan.md` の作成
3. **Tasks（タスク分解）**: `tasks.md` の作成
4. **Implement（実装実行）**: BDD/TDD 2重ループで実装

## 開発手法

### BDD/TDD 2重ループ

**外側のループ（BDD - Behavior-Driven Development）**:
- 統合テスト（受入基準のテスト）を作成
- Red → Green → Refactor のサイクル

**内側のループ（TDD - Test-Driven Development）**:
- ユニットテストを作成（ケントベック流の振る舞い駆動）
- Red → Green → Refactor のサイクル

## ファイル構成

```
spec_driven/
├── spec.md              # 仕様書（What/Why）
├── plan.md              # 技術計画書（How）
├── tasks.md             # タスクリスト（実行可能な最小単位）
├── reversi_core.py      # 合法手判定ロジック
├── reversi.py           # メインプログラム（入出力と統合）
├── test_reversi.py      # テストコード（14個のテスト）
└── README.md            # このファイル
```

### 各ファイルの役割

#### reversi_core.py
合法手判定の核となるロジック：
- `can_place_and_flip(grid, row, col, player)`: 指定位置が合法手かを判定
- `find_legal_moves(grid, player)`: すべての合法手を見つける

#### reversi.py
入出力処理とメインエントリポイント：
- `read_input()`: 標準入力から盤面と手番を読み込み
- `write_output(grid, legal_moves, player)`: 合法手をマークして出力
- `main()`: メイン処理

#### test_reversi.py
テストコード：
- **統合テスト（5個）**: AC-001 〜 AC-005
- **ユニットテスト（9個）**: 各関数の振る舞いテスト

## セットアップ

### 必要な環境
- Python 3.7以上
- pytest（テスト実行用）

### インストール
```bash
pip install pytest
```

## 実行方法

### プログラムの実行
```bash
# 標準入力から読み込み
python reversi.py

# ファイルから読み込み
python reversi.py < input.txt
```

### 入力形式
```
........
........
........
...BW...
...WB...
........
........
........
B
```
- 最初の8行：盤面（8×8）
- 9行目：手番（'B' または 'W'）

### 出力形式
```
........
........
....0...
...BW0..
..0WB...
...0....
........
........
B
```
- 合法手の位置に `'0'` がマークされる
- 最後の行：手番

## テスト実行方法

### すべてのテストを実行
```bash
pytest test_reversi.py -v
```

### 特定のテストを実行
```bash
# 統合テスト（AC-001）のみ
pytest test_reversi.py::test_初期配置で黒番の合法手を正しく表示する -v

# ユニットテストのみ
pytest test_reversi.py -k "can_place_and_flip" -v
```

### テスト結果
```
14 passed in 0.01s
```

## 開発の流れ

### 1. Specify（仕様策定）
`spec.md` を作成：
- 問題の理解と整理
- 受入基準（AC-001 〜 AC-006）の定義
- Given-When-Then 形式で記述

### 2. Plan（技術計画）
`plan.md` を作成：
- データ構造の設計
- 関数設計（シグネチャ、アルゴリズム）
- ファイル構成
- 実装手順

### 3. Tasks（タスク分解）
`tasks.md` を作成：
- 18個のタスクに分解
- BDD/TDD 2重ループで構成
- 各タスクに完了定義を設定

### 4. Implement（実装実行）
BDD/TDD 2重ループで実装：

**外側のループ1（AC-001）**:
1. タスク1-1: 統合テスト作成（Red）
2. 内側のループ（TDD）:
   - タスク1-2: can_place_and_flip ユニットテスト（Red）
   - タスク1-3: can_place_and_flip 実装（Green）
   - タスク1-4: can_place_and_flip リファクタリング
   - タスク1-5 〜 1-9: 同様に進める
3. タスク1-10: 統合テスト確認（Green）
4. タスク1-11: 全体リファクタリング

**外側のループ2 〜 4（AC-002 〜 AC-005）**:
- 同様のサイクルを繰り返す

**フェーズ5（最終検証）**:
- タスク5-1: 全テスト実行と手動確認
- タスク5-2: README作成
- タスク5-3: 最終コミット

## 受入基準の検証

すべての受入基準（AC-001 〜 AC-005）をテストでカバー：

| 受入基準 | テスト | 状態 |
|---------|-------|------|
| AC-001 | test_初期配置で黒番の合法手を正しく表示する | ✅ Pass |
| AC-002 | test_初期配置で白番の合法手を正しく表示する | ✅ Pass |
| AC-003 | test_合法手がない場合は0をマークしない | ✅ Pass |
| AC-004 | test_複数方向にひっくり返せる場合も正しく判定する | ✅ Pass |
| AC-005 | test_端や角での合法手判定がエラーなく動作する | ✅ Pass |

## 実装の特徴

### シンプルさを重視
- 過度な抽象化を避ける
- 可読性を優先
- 必要最小限の関数構成

### テスト駆動
- すべての機能にテストがある
- 統合テストとユニットテストの両方
- 振る舞い駆動のテスト名

### 段階的な実装
- BDD/TDD 2重ループで段階的に実装
- 各ステップで動作確認
- リファクタリングフェーズを設ける

## まとめ

仕様駆動開発により、以下を実現：

- ✅ 明確な仕様（spec.md）
- ✅ 詳細な技術計画（plan.md）
- ✅ 実行可能なタスクリスト（tasks.md）
- ✅ 高品質な実装（14個のテストがすべてパス）
- ✅ 保守しやすいコード構造

BDD/TDD 2重ループにより、品質と開発速度を両立できました。
