# リバーシ合法手判定プログラム - タスクリスト

## 概要

このタスクリストは、spec.mdの仕様とplan.mdの技術計画を実行可能な最小単位のタスクに分解したものです。各タスクはAIエージェントが1回の実行で完了できるサイズに調整されています。

## タスクステータス

- ⏳ **未着手**: まだ開始していない
- 🔄 **実施中**: 現在作業中
- ✅ **完了**: 完了済み

---

## フェーズ0: 環境準備

### タスク0-1: reversi_core.py の骨格作成

**目的**: 合法手判定ロジックの基本構造を準備

**作業内容**:
1. `reversi_core.py` ファイルを作成
2. 必要なimport文を追加（`from typing import List, Tuple`）
3. 関数のスケルトン（型ヒント付き）を定義:
   - `can_place_and_flip(grid: List[List[str]], row: int, col: int, player: str) -> bool`
   - `find_legal_moves(grid: List[List[str]], player: str) -> List[Tuple[int, int]]`
4. 各関数にdocstringを追加（日本語）
5. 一時的に `pass` または `return False` / `return []` を記述

**完了定義**:
- [x] reversi_core.py ファイルが存在する
- [x] 2つの関数が型ヒント付きで定義されている
- [x] 各関数にdocstringがある
- [x] Pythonの構文エラーがない（`python reversi_core.py` で確認）

**状態**: ⏳ 未着手

---

## フェーズ1: 核となるロジック実装

### タスク1-1: can_place_and_flip 関数の実装

**目的**: 指定位置が合法手かどうかを判定する関数を実装

**作業内容**:
1. `can_place_and_flip` 関数を実装:
   - 範囲チェック（0 <= row < 8 and 0 <= col < 8）
   - 空マスチェック（grid[row][col] == '.'）
   - 相手プレイヤーの判定（opponent = 'W' if player == 'B' else 'B'）
   - 8方向のループ処理
   - 各方向について、相手のコマを挟めるかチェック

**完了定義**:
- [x] 関数が実装されている
- [x] 8方向すべてについて判定を行っている
- [x] 盤面外アクセスのチェックが含まれている
- [x] plan.mdの「7.1 合法手判定アルゴリズム」に従っている
- [x] Pythonの構文エラーがない

**状態**: ⏳ 未着手

---

### タスク1-2: find_legal_moves 関数の実装

**目的**: すべての合法手を見つける関数を実装

**作業内容**:
1. `find_legal_moves` 関数を実装:
   - 盤面の全マス（8×8 = 64マス）をループ
   - 各マスについて `can_place_and_flip` を呼び出し
   - Trueが返された座標を `List[Tuple[int, int]]` に追加
   - リストを返す

**完了定義**:
- [x] 関数が実装されている
- [x] 64マスすべてをチェックしている
- [x] `can_place_and_flip` を使用している
- [x] 正しい型（`List[Tuple[int, int]]`）を返している
- [x] Pythonの構文エラーがない

**状態**: ⏳ 未着手

---

### タスク1-3: reversi_core.py の簡易動作確認

**目的**: ロジックが正しく動作することを確認

**作業内容**:
1. Pythonインタプリタまたは簡易スクリプトで動作確認:
   - 初期配置の盤面データを作成
   - `find_legal_moves` を呼び出し
   - 結果が spec.md の AC-001（黒番: 4つの合法手）と一致するか確認

**完了定義**:
- [x] 初期配置・黒番で `[(2, 4), (3, 5), (4, 2), (5, 3)]` が返される
- [x] エラーが発生しない

**状態**: ⏳ 未着手

---

## フェーズ2: 入出力処理実装

### タスク2-1: reversi.py の骨格作成

**目的**: メインプログラムの基本構造を準備

**作業内容**:
1. `reversi.py` ファイルを作成
2. 必要なimport文を追加:
   - `from typing import List, Tuple`
   - `from reversi_core import find_legal_moves`
3. 関数のスケルトン（型ヒント付き）を定義:
   - `read_input() -> Tuple[List[List[str]], str]`
   - `write_output(grid: List[List[str]], legal_moves: List[Tuple[int, int]], player: str) -> None`
   - `main() -> None`
4. 各関数にdocstringを追加（日本語）
5. `if __name__ == "__main__":` ブロックを追加

**完了定義**:
- [x] reversi.py ファイルが存在する
- [x] 3つの関数が型ヒント付きで定義されている
- [x] reversi_core.py をimportしている
- [x] Pythonの構文エラーがない

**状態**: ⏳ 未着手

---

### タスク2-2: read_input 関数の実装

**目的**: 標準入力から盤面と手番を読み込む関数を実装

**作業内容**:
1. `read_input` 関数を実装:
   - `input()` で9行読み込む
   - 最初の8行を `list()` で文字のリストに変換
   - 8行分を2次元リスト `List[List[str]]` にまとめる
   - 9行目を手番として保存（`.strip()` で前後の空白除去）
   - `(grid, player)` のタプルを返す

**完了定義**:
- [x] 関数が実装されている
- [x] 9行の入力を正しく処理している
- [x] 盤面データが `List[List[str]]` 型である
- [x] plan.mdの「4.3 入出力関数」の実装例に従っている
- [x] Pythonの構文エラーがない

**状態**: ⏳ 未着手

---

### タスク2-3: write_output 関数の実装

**目的**: 合法手をマークした盤面を標準出力に書き込む関数を実装

**作業内容**:
1. `write_output` 関数を実装:
   - 盤面をコピー（`output_grid = [row[:] for row in grid]`）
   - 合法手の座標リストをループ
   - 各座標 `(row, col)` に対して `output_grid[row][col] = '0'` を設定
   - 各行を `''.join(row)` で文字列に変換して `print()`
   - 手番を `print(player)` で出力

**完了定義**:
- [x] 関数が実装されている
- [x] 元の盤面を変更していない（コピーを使用）
- [x] 合法手の位置に '0' をマークしている
- [x] 8行の盤面と1行の手番を出力している
- [x] plan.mdの「4.3 入出力関数」の実装例に従っている
- [x] Pythonの構文エラーがない

**状態**: ⏳ 未着手

---

### タスク2-4: main 関数の実装

**目的**: プログラム全体のフローを統合

**作業内容**:
1. `main` 関数を実装:
   - `read_input()` を呼び出して `grid, player` を取得
   - `find_legal_moves(grid, player)` を呼び出して合法手リストを取得
   - `write_output(grid, legal_moves, player)` を呼び出して結果を出力

**完了定義**:
- [x] 関数が実装されている
- [x] 3つの関数を正しい順序で呼び出している
- [x] plan.mdの「5.1 メイン処理」に従っている
- [x] Pythonの構文エラーがない

**状態**: ⏳ 未着手

---

### タスク2-5: reversi.py の手動動作確認

**目的**: プログラム全体が正しく動作することを確認

**作業内容**:
1. spec.md の AC-001 の入力例を使って手動テスト:
   - 入力データをファイル（例: `input_black.txt`）に保存
   - `python reversi.py < input_black.txt` を実行
   - 出力が spec.md の AC-001 の期待出力と一致するか確認

**完了定義**:
- [x] プログラムがエラーなく実行される
- [x] 出力が spec.md の AC-001 の期待出力と一致する
- [x] 合法手が正しく '0' でマークされている

**状態**: ⏳ 未着手

---

## フェーズ3: テストと検証

### タスク3-1: test_reversi.py の骨格作成

**目的**: テストファイルの基本構造を準備

**作業内容**:
1. `test_reversi.py` ファイルを作成
2. 必要なimport文を追加:
   - `import pytest`（あればで良い、なくても可）
   - `from reversi_core import can_place_and_flip, find_legal_moves`
3. テスト関数のスケルトンを定義:
   - `test_初期配置で黒番の合法手を正しく判定する()`
   - `test_初期配置で白番の合法手を正しく判定する()`
   - `test_合法手がない場合は空リストを返す()`
4. 各テスト関数にdocstringを追加（spec.mdの受入基準を参照）

**完了定義**:
- [x] test_reversi.py ファイルが存在する
- [x] 3つのテスト関数が定義されている
- [x] reversi_core をimportしている
- [x] Pythonの構文エラーがない

**状態**: ⏳ 未着手

---

### タスク3-2: AC-001 のテスト実装

**目的**: 初期配置・黒番の合法手判定をテスト

**作業内容**:
1. `test_初期配置で黒番の合法手を正しく判定する()` を実装:
   - spec.md の AC-001 の盤面データを作成
   - `find_legal_moves(grid, 'B')` を呼び出し
   - 結果が `[(2, 4), (3, 5), (4, 2), (5, 3)]` と一致するか `assert` で検証
   - 順序が異なる可能性があるため、`set()` で比較することも検討

**完了定義**:
- [x] テスト関数が実装されている
- [x] spec.md の AC-001 の盤面データを使用している
- [x] 期待される4つの合法手を検証している
- [x] `python test_reversi.py` または `pytest test_reversi.py` で実行できる
- [x] テストがパスする

**状態**: ⏳ 未着手

---

### タスク3-3: AC-002 のテスト実装

**目的**: 初期配置・白番の合法手判定をテスト

**作業内容**:
1. `test_初期配置で白番の合法手を正しく判定する()` を実装:
   - spec.md の AC-002 の盤面データを作成（AC-001と同じ初期配置）
   - `find_legal_moves(grid, 'W')` を呼び出し
   - 結果が `[(2, 3), (3, 2), (4, 5), (5, 4)]` と一致するか検証

**完了定義**:
- [x] テスト関数が実装されている
- [x] spec.md の AC-002 の盤面データを使用している
- [x] 期待される4つの合法手を検証している
- [x] テストがパスする

**状態**: ⏳ 未着手

---

### タスク3-4: AC-003 のテスト実装

**目的**: 合法手がない場合のテスト

**作業内容**:
1. `test_合法手がない場合は空リストを返す()` を実装:
   - 合法手がない盤面データを作成（例: すべて埋まった盤面、または孤立したコマ）
   - `find_legal_moves(grid, 'B')` を呼び出し
   - 結果が空リスト `[]` であるか検証

**完了定義**:
- [x] テスト関数が実装されている
- [x] 合法手がない盤面データを使用している
- [x] 空リストが返されることを検証している
- [x] テストがパスする

**状態**: ⏳ 未着手

---

### タスク3-5: エッジケースのテスト追加（任意）

**目的**: spec.md の AC-004, AC-005 に対応するテストを追加

**作業内容**:
1. `test_複数方向にひっくり返せる場合の判定()` を実装（AC-004）:
   - spec.md の AC-004 の盤面データを作成
   - `can_place_and_flip(grid, 3, 3, 'W')` が True を返すか検証
2. `test_端や角での合法手判定()` を実装（AC-005）:
   - 端や角にコマがある盤面データを作成
   - `find_legal_moves()` がエラーなく実行されるか確認

**完了定義**:
- [x] 2つのテスト関数が実装されている
- [x] spec.md の AC-004, AC-005 に対応している
- [x] すべてのテストがパスする

**状態**: ⏳ 未着手

---

### タスク3-6: 全テストの実行と確認

**目的**: すべてのテストが通ることを確認

**作業内容**:
1. テストをすべて実行:
   - `python test_reversi.py` または `pytest test_reversi.py -v`
2. すべてのテストがパスすることを確認
3. テストが失敗する場合は、該当する実装を修正

**完了定義**:
- [x] すべてのテストがパスする
- [x] テスト実行時にエラーが発生しない

**状態**: ⏳ 未着手

---

## フェーズ4: ドキュメント作成

### タスク4-1: README.md の作成

**目的**: spec_driven アプローチの説明とプログラムの使い方を記載

**作業内容**:
1. `README.md` ファイルを作成
2. 以下の内容を記載:
   - アプローチの概要（spec.md → plan.md → tasks.md → 実装）
   - ファイル構成の説明
   - セットアップ方法（pytestのインストールなど）
   - 実行方法（`python reversi.py` の使い方）
   - テスト実行方法（`pytest test_reversi.py`）
   - 入出力フォーマットの説明

**完了定義**:
- [x] README.md ファイルが存在する
- [x] 必要な情報が記載されている（概要、使い方、テスト方法）
- [x] コードブロックが適切にフォーマットされている

**状態**: ⏳ 未着手

---

### タスク4-2: 最終確認とコミット

**目的**: すべての成果物が完成していることを確認

**作業内容**:
1. 以下のファイルが存在することを確認:
   - reversi_core.py
   - reversi.py
   - test_reversi.py
   - spec.md
   - plan.md
   - tasks.md
   - README.md
2. すべてのテストがパスすることを再確認
3. 手動テスト（問題文の入出力例）で動作確認
4. Git コミット（適切なコミットメッセージ）

**完了定義**:
- [x] すべてのファイルが存在する
- [x] すべてのテストがパスする
- [x] 手動テストで正しい出力が得られる
- [x] Git コミット済み

**状態**: ⏳ 未着手

---

## 進捗サマリー

**完了タスク数**: 0 / 16

**フェーズ別進捗**:
- フェーズ0（環境準備）: 0 / 1
- フェーズ1（核となるロジック）: 0 / 3
- フェーズ2（入出力処理）: 0 / 5
- フェーズ3（テストと検証）: 0 / 5
- フェーズ4（ドキュメント）: 0 / 2

---

## 注意事項

1. **各タスクは1回の実行で完了できるサイズ**: 30分〜1時間程度の作業量
2. **完了定義を満たすまで次のタスクに進まない**: 品質保証
3. **テストファーストではない**: plan.mdの方針に従い、実装を先に行う
4. **spec.md の受入基準を満たすことが最終目標**: AC-001〜AC-006

---

## タスク実行時のガイドライン

- **1つのタスクに集中**: 複数のタスクを同時に進めない
- **完了定義を確認**: すべての項目をチェック
- **問題があれば報告**: 不明点や問題があれば即座に報告
- **コミットのタイミング**: 各フェーズ完了時、または意味のある単位でコミット
