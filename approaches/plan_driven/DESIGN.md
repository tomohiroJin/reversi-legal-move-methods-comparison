# plan_driven アプローチ - 設計書

## 1. 概要

このドキュメントは、plan_driven アプローチでリバーシ合法手判定プログラムを実装するための設計書です。
実装前に全体のアーキテクチャ、クラス設計、データフローを明確化します。

## 2. アーキテクチャ

### 2.1 レイヤードアーキテクチャ

本プログラムは、レイヤードアーキテクチャを採用します。

```
┌─────────────────────────────────────┐
│     reversi.py (Entry Point)        │  ← メインエントリポイント
└─────────────────────────────────────┘
           ↓              ↓
┌──────────────────┐  ┌──────────────────┐
│   IO層           │  │  Domain層         │
│  - InputReader   │  │  - Board          │  ← ビジネスロジック
│  - OutputWriter  │  │  - GameRules      │
└──────────────────┘  └──────────────────┘
```

### 2.2 責任の分離

- **Domain層**: ビジネスロジック（盤面管理、合法手判定）
- **IO層**: 入出力処理（標準入力からの読み込み、標準出力への書き込み）
- **Entry Point**: 全モジュールの統合とプログラムの実行フロー制御

## 3. クラス設計

### 3.1 Board クラス（domain/board.py）

#### 責任
- 盤面の状態を管理する
- セルへのアクセスを提供する
- 盤面に関する基本的な操作を提供する
- **ゲームロジックは含まない**（単一責任の原則）

#### クラス定数
```python
EMPTY: str = '.'    # 空マス
BLACK: str = 'B'    # 黒のコマ
WHITE: str = 'W'    # 白のコマ
SIZE: int = 8       # 盤面のサイズ
```

#### メソッド

| メソッド名 | 引数 | 戻り値 | 説明 |
|-----------|-----|--------|------|
| `__init__` | `grid: List[List[str]]` | なし | 盤面を初期化する |
| `get_cell` | `row: int, col: int` | `str` | 指定位置のセルの値を取得 |
| `is_valid_position` | `row: int, col: int` | `bool` | 指定位置が盤面内かチェック |
| `is_empty` | `row: int, col: int` | `bool` | 指定位置が空マスかチェック |
| `to_grid` | なし | `List[List[str]]` | 盤面データを取得（コピー） |
| `get_opponent` | `player: str` | `str` | 相手プレイヤーを取得（静的メソッド） |

#### データ構造
```python
_grid: List[List[str]]  # 8x8の盤面（内部状態）
```

### 3.2 GameRules クラス（domain/game_rules.py）

#### 責任
- リバーシのゲームルールを実装する
- 合法手の判定を行う
- 全合法手の列挙を行う
- **盤面の状態は変更しない**（副作用を避ける）

#### クラス定数
```python
DIRECTIONS: List[Tuple[int, int]] = [
    (-1, -1), (-1, 0), (-1, 1),  # 上方向3つ
    (0, -1),           (0, 1),    # 左右
    (1, -1),  (1, 0),  (1, 1)     # 下方向3つ
]
```

#### メソッド

| メソッド名 | 引数 | 戻り値 | 説明 |
|-----------|-----|--------|------|
| `__init__` | `board: Board` | なし | GameRules を初期化 |
| `can_flip_in_direction` | `row, col, dr, dc, player` | `bool` | 特定の方向にひっくり返せるかチェック |
| `is_legal_move` | `row, col, player` | `bool` | 指定位置が合法手かチェック |
| `find_all_legal_moves` | `player` | `List[Tuple[int, int]]` | 全合法手を列挙 |

#### アルゴリズム詳細

**can_flip_in_direction の判定ロジック:**

1. 隣接マス `(row+dr, col+dc)` が盤面内かチェック
2. 隣接マスに相手のコマがあるかチェック → なければ False
3. その方向に進み続ける:
   - 空マス '.': False（ひっくり返せない）
   - 自分のコマ: True（ひっくり返せる）
   - 相手のコマ: さらに進む
   - 盤面外: False

```
例: 黒番で (2,4) に置く場合の下方向チェック

    0 1 2 3 4 5 6 7
  ┌─────────────────
0 │ . . . . . . . .
1 │ . . . . . . . .
2 │ . . . . ? . . .  ← ここに置く
3 │ . . . B W . . .
4 │ . . . W B . . .  ← (3,4)=W, (4,4)=B
5 │ . . . . . . . .
  ...

方向: dr=1, dc=0（下方向）

ステップ1: (2+1, 4+0) = (3,4) → 'W'（相手のコマ）✓
ステップ2: (3+1, 4+0) = (4,4) → 'B'（自分のコマ）✓
→ True（ひっくり返せる）
```

### 3.3 InputReader クラス（io/input_reader.py）

#### 責任
- 標準入力から盤面と手番を読み込む
- 入力データをパースしてBoard オブジェクトに変換する

#### メソッド

| メソッド名 | 引数 | 戻り値 | 説明 |
|-----------|-----|--------|------|
| `read_from_stdin` | なし | `Tuple[Board, str]` | 標準入力から盤面と手番を読み込む |

#### 処理フロー
1. 標準入力から9行読み込み
2. 最初の8行を盤面データとして解析
3. 9行目を手番として解析
4. Boardオブジェクトを生成
5. (Board, 手番) のタプルを返す

### 3.4 OutputWriter クラス（io/output_writer.py）

#### 責任
- 盤面と合法手を標準出力に書き込む
- 合法手の位置に '0' をマークする

#### メソッド

| メソッド名 | 引数 | 戻り値 | 説明 |
|-----------|-----|--------|------|
| `write_board_with_legal_moves` | `board, legal_moves, player` | `None` | 合法手をマークして出力 |

#### 処理フロー
1. 盤面をコピー
2. 合法手の位置に '0' をマーク
3. 8行の盤面を出力
4. 手番を出力

## 4. データフロー

```
[ 標準入力 ]
     ↓
[ InputReader.read_from_stdin() ]
     ↓
(Board, player: str)
     ↓
[ GameRules(board).find_all_legal_moves(player) ]
     ↓
legal_moves: List[Tuple[int, int]]
     ↓
[ OutputWriter.write_board_with_legal_moves(board, legal_moves, player) ]
     ↓
[ 標準出力 ]
```

## 5. 入出力仕様

### 入力形式
```
........    ← 盤面1行目（8文字）
........    ← 盤面2行目
........    ← 盤面3行目
...BW...    ← 盤面4行目
...WB...    ← 盤面5行目
........    ← 盤面6行目
........    ← 盤面7行目
........    ← 盤面8行目
B           ← 手番（'B' または 'W'）
```

### 出力形式
```
........    ← 盤面1行目
........    ← 盤面2行目
....0...    ← 盤面3行目（合法手を '0' で表示）
...BW0..    ← 盤面4行目
..0WB...    ← 盤面5行目
...0....    ← 盤面6行目
........    ← 盤面7行目
........    ← 盤面8行目
B           ← 手番
```

## 6. テスト戦略

### 6.1 ユニットテスト

**tests/test_board.py**
- Board クラスの各メソッドをテスト
- 境界値テスト（盤面外のアクセス）
- 空マスチェック
- get_opponent の正しさ

**tests/test_game_rules.py**
- can_flip_in_direction の各方向テスト
- is_legal_move の各パターンテスト
- find_all_legal_moves の初期配置テスト

### 6.2 統合テスト

**test_reversi.py**
- エンドツーエンドのテスト
- 問題文の例を使ったテスト
- 初期配置（黒番、白番）
- 合法手がない場合
- エッジケース

## 7. 実装の優先順位

1. **Board クラス** → 基盤となるデータ構造
2. **Board のテスト** → Board の正しさを保証
3. **GameRules クラス** → コアロジック
4. **GameRules のテスト** → ロジックの正しさを保証
5. **InputReader クラス** → 入力処理
6. **OutputWriter クラス** → 出力処理
7. **reversi.py** → 統合
8. **統合テスト** → 全体の動作確認

## 8. 非機能要件

### 8.1 コーディング規約
- 日本語でdocstringを記述
- 型ヒントを完備
- 1行80文字以内を推奨

### 8.2 パフォーマンス
- 8x8の盤面なので、パフォーマンスは問題にならない
- 可読性とメンテナンス性を優先

### 8.3 拡張性
- 各クラスの責任を明確に分離
- 将来的な拡張（GUI、AI対戦）に対応しやすい設計
- domain層はio層に依存しない（依存関係の逆転）

## 9. 設計の根拠

### 9.1 なぜレイヤードアーキテクチャか

- **責任の明確化**: domain層とio層を分離することで、各層の責任が明確になる
- **テストしやすさ**: domain層は入出力に依存しないため、ユニットテストが容易
- **拡張性**: 将来、GUI版やWeb版を作る際、domain層を再利用できる

### 9.2 なぜクラスベースか

- **状態のカプセル化**: Board は盤面の状態を持つため、クラスが適切
- **メソッドのグループ化**: 関連するメソッドをまとめることで可読性向上
- **単一責任の原則**: 各クラスが1つの責任のみを持つ

### 9.3 なぜBoard とGameRules を分離するか

- **Board**: 「盤面の状態管理」という責任
- **GameRules**: 「ゲームルールの判定」という責任
- 分離することで、それぞれが独立してテスト可能になる

## 10. まとめ

本設計書に基づいて実装を進めることで、以下を実現します：

1. **明確な責任分離**: 各クラスが単一責任を持つ
2. **高いテスタビリティ**: ユニットテスト・統合テストが容易
3. **高い保守性**: コードの意図が明確で、変更が容易
4. **高い拡張性**: 将来の機能追加に対応しやすい

この設計書を実装の指針として、計画的に開発を進めます。
